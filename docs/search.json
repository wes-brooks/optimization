[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Function optimization",
    "section": "",
    "text": "Overview\nOptimization here is understood to mean function optimization, which is finding the parameters that minimize or maximize a function. This is how parameters are estimated - for instance, you might observe the motion of some falling objects and use that data to estimate the constant of gravitational acceleration. In this example, you’d start with an equation derived from theory, like: \\[ y(t) = \\frac{gt^2}{2} \\] plus some data (observations of \\(y\\) and \\(t\\)), then use optimization to find the value of \\(g\\) that fits the data best.\nWhat does it mean to “fit the data best”? In this case, you’d probably use a measure of error that can handle errors to both positive and negative directions, like squared error (\\(\\sum_{i=1}^n(y_i - \\frac{gt_i^2}{2})^2\\)) or absolute error (\\(\\sum_{i=1}^n|y_i - \\frac{gt_i^2}{2}|\\)). Then you would minimize the error. This minimization (or maximization) is what optimization is all about."
  },
  {
    "objectID": "index.html#webr-example",
    "href": "index.html#webr-example",
    "title": "Function optimization",
    "section": "WebR example",
    "text": "WebR example\n\n\nLoading webR…"
  },
  {
    "objectID": "01_types.html#continuous-parameters",
    "href": "01_types.html#continuous-parameters",
    "title": "Types of optimization problems",
    "section": "Continuous parameters",
    "text": "Continuous parameters\nIn the case of continuous parameters (like the gravity example before), the basic task is to where the derivative of loss with respect to the parameters is zero. Most (all?) algorithms will find a local minimum, with no guarantee that it finds the global minimum. There are two basic categories of optimizer for continuous parameters: closed form and iterative. A closed form optimizer is a special solution to a specific problem, and generally can’t be applied to a different problem. So, most (all?) generic optimizers are iterative: they progress toward the solution in repeated steps until the steps get small enough that we say the algorithm has converged.\nNext, we can break optimization algorithms into categories based on how much information we have about the derivatives of the function w.r.t. the parameters. The most common categories are to have: 0. No knowledge of the derivatives. 1. Known first derivative. 2. Known first and second derivatives.\nHere is an example:\n#| echo: FALSE\nf = function(t) {((t - 2.1)^3 + (t-5)/3)^2 + 3}\nfw = function(t) {(((t - 3.1))^3 + t^2/2.2 - 5*t/2.2)^2 + 3}\nfww = function(t) {(t-6)^2 * (t-5)^2 + t^2}\nxx = seq(2, 8, length.out=201)\n\nplot(xx, fww(xx), type='l', bty='n', xlab=\"\", ylab=\"\")\n# axis(2, pos=0, at=c(-5, 5, 10, 15, 20))\n# axis(1, pos=0, at=c(-1, 1, 2, 3, 4, 5))\n# \n# points(2.98, 3, col='red', pch=16)\n# \n# lines(c(2.98,2.98), c(0,3), lty=3)\n\n# derivatives one and two, plus the quadratic interpolation\nf1 = function(t) {2*((t-2.1)^3 + (t-5)/3) * (3*(t-2.1)^2 + 1/3)}\nf2 = function(t) {2*(3*(t-2.1)^2 + 1/3)^2 + 2*((t-2.1)^2 + (t-5)/3)*6*(t-2.1)}\n\nff = function(t, start=1) {f2(start)/2*(t- (start - f1(start)/f2(start)))^2 + f(start) - f2(start)/2*(start- (start - f1(start)/f2(start)))^2 }\n\nfw1 = function(t) {2*((t-3.1)^3 + t^2/2.2 - 5*t/2.2) * (3*(t-3.1)^2 + 2*t/2.2 - 5/2.2)}\nfw2 = function(t) {2*( (3*(t-3.1)^2 + t*2/2.2 - 5/2.2) * (3*(t-3.1)^2 + 2*t/2.2 - 5/2.2) + ((t-3.1)^3 + t^2/2.2 - 5*t/2.2) * (6*(t-3.1) + 2/2.2))}\n\nfwf = function(t, start=1) {fw2(start)/2*(t- (start - fw1(start)/fw2(start)))^2 + fw(start) - fw2(start)/2*(start- (start - fw1(start)/fw2(start)))^2 }\n\n\nfww1 = function(t) {2*(t-6)*(t-5)^2 + 2*(t-6)^2*(t-5) + 2*t}\nfww2 = function(t) {2*(t-5)^2 + 4*(t-6)*(t-5) + 4*(t-6)*(t-5) + 2*(t-6)^2 + 2}\n\nfwwf = function(t, start=1) {fww2(start)/2*(t- (start - fww1(start)/fww2(start)))^2 + fww(start) - fww2(start)/2*(start- (start - fww1(start)/fww2(start)))^2 }\n\n# first step\nnr_iterate = function(xloc) {\n  \n  lines(xx, fwwf(xx, start=xloc), lty=2)\n  xnew = xloc - fww1(xloc)/fww2(xloc)\n  points(xloc, fww(xloc), col='red', pch=16)\n\n  xnew\n}\n\n# setup for iteration:\nnr_path = c(2.5) \n\n#iterate:\nx_new = nr_iterate(tail(nr_path, 1))\nnr_path = c(nr_path, x_new)\n\n\n\n# \n# lines(xx, fwwf(xx, 2.5), lty=2)\n# x2 = 2.5 - fww1(2.5)/fww2(2.5)\n# points(2.5, fww(2.5), col='red', pch=16)\n# \n# \n# # second step\n# lines(xx, fwwf(xx, start=x2), lty=2)\n# x3 = x2 - fww1(x2)/fww2(x2)\n# points(x2, fww(x2), col='red', pch=16)\n# \n# \n# # third step\n# lines(xx, fwwf(xx, start=x3), lty=2)\n# x4 = x3 - fww1(x3)/fww2(x3)\n# points(x3, fww(x3), col='red', pch=16)\n# \n# # fourth step\n# lines(xx, fwwf(xx, start=x4), lty=2)\n# x5 = x4 - fww1(x4)/fww2(x4)\n# points(x4, fww(x4), col='red', pch=16)\n# \n# \n# # fifth step\n# lines(xx, fwwf(xx, start=x5), lty=2)\n# x6 = x5 - fww1(x5)/fww2(x5)\n# points(x5, fww(x5), col='red', pch=16)\n#iterate:\nx_new = nr_iterate(tail(nr_path, 1))\nnr_path = c(nr_path, x_new)\n\n#| echo: FALSE\nf = function(t) {((t - 2.1)^3 + (t-5)/3)^2 + 3}\nfw = function(t) {(((t - 3.1))^3 + t^2/2.2 - 5*t/2.2)^2 + 3}\nfww = function(t) {(t-6)^2 * (t-5)^2 + t^2}\nxx = seq(2, 8, length.out=201)\n\nplot(xx, fww(xx), type='l', bty='n', xlab=\"\", ylab=\"\")\n# axis(2, pos=0, at=c(-5, 5, 10, 15, 20))\n# axis(1, pos=0, at=c(-1, 1, 2, 3, 4, 5))\n# \n# points(2.98, 3, col='red', pch=16)\n# \n# lines(c(2.98,2.98), c(0,3), lty=3)\n\n# derivatives one and two, plus the quadradic interpolation\nfww1 = function(t) {2*(t-6)*(t-5)^2 + 2*(t-6)^2*(t-5) + 2*t}\nfww2 = function(t) {2*(t-5)^2 + 4*(t-6)*(t-5) + 4*(t-6)*(t-5) + 2*(t-6)^2 + 2}\n\nfww1f = function(t, start=1) {fww2(start)/2*(t- (start - fww1(start)/fww2(start)))^2 + fww(start) - fww2(start)/2*(start- (start - fww1(start)/fww2(start)))^2 }\n\n# first step\n\n# lines(xx, fwwf(xx, 2.5), lty=2)\ngd_iterate = function(gamma, x_last) {\n  finished = FALSE\n  while (!finished) {\n    # x_last = tail(path, 1)\n    \n    gamma = gamma / 0.8 * (-sign(fww1(x_last)))\n    trial = fww(x_last + gamma)\n    if (trial &gt; fww(x_last) + 0.2*gamma*fww1(x_last)) {\n      \n      gamma = gamma * 0.8^2\n    } else {\n      x_next = x_last + gamma\n      # path = c(path, x_next)\n      finished = TRUE\n    }\n  }\n  \n  lines( c(x_last, x_next), c(fww(x_last), fww(x_last) + gamma*fww1(x_last)), lty=2)\n  points(x_last, fww(x_last), col='red', pch=1)\n  \n  list(\"gamma\" = gamma, \"x_new\" = x_next)\n}\n\npath = c(2.5)\ngamma = 0.2\n\n# iterate this part to get the solution:\nresult = gd_iterate(gamma, tail(path, 1))\ngamma = result[[\"gamma\"]]\nxloc = result[[\"x_new\"]]\npath = c(path, xloc)\n# iterate this part to get the solution:\nresult = gd_iterate(gamma, tail(path, 1))\ngamma = result[[\"gamma\"]]\nxloc = result[[\"x_new\"]]\npath = c(path, xloc)"
  }
]